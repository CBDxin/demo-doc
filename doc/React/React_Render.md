React 并不关心你的代码是否像严格的函数式编程一样百分百纯净。在 React 中，幂等性比纯净性更加重要。也就是说，在 React 组件中不允许有用户可以直接看到的副作用。换句话说，仅调用函数式组件时不应该在屏幕上产生任何变化。

## 协调
React 的工作是将 React 元素树映射到宿主树上去。确定该对宿主实例做什么来响应新的信息有时候叫做协调 。

## 惰性求值
当我们在 JavaScript 中调用函数时，参数往往在函数调用之前被执行。
```
// (2) 它会作为第二个计算
eat(
  // (1) 它会首先计算
  prepareMeal()
);
```
但是，React 组件是相对纯净的。如果我们知道组件的结果不会在屏幕上出现，则完全没有必要执行它。
```
function Page({ currentUser, children }) {
  if (!currentUser.isLoggedIn) {
    return <h1>Please login</h1>;
  }
  return (
    <Layout>
      {children}
    </Layout>
  );
}
```

```
//未登录时React元素不会被执行
<Page user={currentUser}>
      <Comments />
    </Page>
```

```
//会被立即执行
<Page>
  {Comments()}
</Page>

```

## 状态
React 用了许多对对构建UI有好处的特性增强了函数组件，局部属性便是其中之一。这些属性就是我们平时所说的Hooks。

## 一致性
即使我们想将协调过程本身分割成非阻塞的工作块，我们仍然需要在同步的循环中对真实的宿主实例进行操作。这样我们才能保证用户不会看见半更新状态的 UI ，浏览器也不会对用户不应看到的中间状态进行不必要的布局和样式的重新计算。

这也是为什么 React 将所有的工作分成了“渲染阶段”和“提交阶段”的原因。渲染阶段是当 React 调用你的组件然后进行协调的时段。在此阶段进行干涉是安全的且在未来这个阶段将会变成异步的。提交阶段就是 React 操作宿主树的时候。而这个阶段永远是同步的。

## 原始模型
React 并没有使用“反应式”的系统来支持细粒度的更新。换句话说，任何在顶层的更新只会触发协调而不是局部更新那些受影响的组件。

这样的设计是有意而为之的。对于 web 应用来说交互时间是一个关键指标，而通过遍历整个模型去设置细粒度的监听器只会浪费宝贵的时间。此外，在很多应用中交互往往会导致或小（按钮悬停）或大（页面转换）的更新，因此细粒度的订阅只会浪费内存资源。

React 的设计原则之一就是它可以处理原始数据。如果你拥有从网络请求中获得的一组 JavaScript 对象，你可以将其直接交给组件而无需进行预处理。没有关于可以访问哪些属性的问题，或者当结构有所变化时造成的意外的性能缺损。React 渲染是 O(视图大小) 而不是 O(模型大小)

## 批量更新
这就是为什么 React 会在组件内所有事件触发完成后再进行批量更新

## 副作用
 React 组件在渲染过程中不应该有可观察到的副作用。但是有些时候副作用确实必要的。我们也许需要进行管理 focus 状态、用 canvas 画图、订阅数据源等操作。在 React 中，这些都可以通过声明 effect 来完成。

 如果可能，React 会推迟执行 effect 直到浏览器重新绘制屏幕。这是有好处的因为像订阅数据源这样的代码并不会影响交互时间和首次绘制时间 。

 React 会在下次调用该 effect 之前执行这个返回的函数，当然是在组件被摧毁之前。

 ## 静态使用顺序
 