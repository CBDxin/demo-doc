## React Hooks的使用场景

* 模拟生命周期函数；
* 副作用的封装和监听:如useWindowSize、useOnlineStatus；
* 副作用衍生：useEffect、useDebounce；
* DOM事件的封装：useAvtive；
* 获取context；
* 封装可复用的逻辑和状态：useInput、usePromise
    * 取代高阶组件
    * 取代容器组件
* 扩展状态操作：useSetState，useLocalStorage 

## 函数式组件每一次渲染都有它自己的Props and State、事件处理函数

在 React 中 Props 是不可变(immutable)的，所以他们永远不会改变。然而，this是，而且永远是，可变(mutable)的。

React本身会随着时间的推移而改变，以便你可以在渲染方法以及生命周期方法中得到最新的实例。

函数式组件捕获了渲染所使用的值。组件函数每次渲染都会被调用，但是每一次调用中count值都是常量，并且它被赋予了当前渲染中的状态值。

每一个函数组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props和state。effect的清除函数也一样，也能进行props以及state的捕获，所以清除过程“看到”的是旧的props不是因为它是在重新渲染之前运行的，上一次的effect会在重新渲染后被清除

在组件内什么时候去读取props或者state是无关紧要的。因为它们不会改变。在单次渲染的范围内，props和state始终保持不变。

过时闭包问题。（ref解决）

## 每次渲染都有它自己的Effects
并不是state的值在“不变”的effect中发生了改变，而是effect 函数本身在每一次渲染中都不相同。每一个effect版本“看到”的state值都来自于它属于的那次渲染。

## 为什么顺序调用对 React Hooks 很重要

## 同步， 而非生命周期
useEffect使你能够根据props和state同步React tree之外的东西。先渲染属性A，B再渲染C，和立即渲染C并没有什么区别。相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 useState、 useEffect() 和 useLayoutEffect() 来模拟实现生命周期。
即：Hooks 组件更接近于实现状态同步，而不是响应生命周期事件。当我们考虑同步而不是生命周期事件时，它允许我们将相关的逻辑块组合在一起，这就是useEffect要做的事情了。

## 关于依赖项不要对React撒谎
```
  async function fetchData() {
    
  }

  useEffect(() => {
    fetchData();
  }, []); // 这里看似问题不大，但实际可能在fetchData中引用了某些props或者是state而引发bug

```
* 你可以尝试把那个函数移动到你的组件之外。那样一来，这个函数就肯定不会依赖任何 props 或 state，并且也不用出现在依赖列表中了。
* 如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 转而在 effect 之外调用它， 并让 effect 依赖于它的返回值。
* 万不得已的情况下，你可以 把函数加入 effect 的依赖但 把它的定义包裹 进 useCallback Hook。这就确保了它不随渲染而改变，除非 它自身 的依赖发生了改变

